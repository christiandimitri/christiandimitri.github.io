<canvas id='{{include.id}}' class="threeJS-canvas"></canvas>

<script src="{{'assets/js/three.js' | absolute_url}}">
</script>
<script src="{{'assets/js/OrbitControls.js' | absolute_url}}">
</script>
<script src="{{'assets/js/OBJLoader.js' | absolute_url}}">
</script>
<script src="{{'assets/js/MTLLoader.js' | absolute_url}}">
</script>

<script>
    // Our Javascript will go here.
    // console.clear();

    function main() {
        //========= set renderer to 'canvas id' ===============//
        const canvas = document.querySelector('#{{include.id}}');
        // set renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;



        //================== set camera ======================//
        const fov = 45;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 1;
        const far = 5000;
        var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.lookAt(new THREE.Vector3(0, 0, 0)); // Set look at coordinate like this
        camera.position.z = 1000;
        camera.position.y = 1000;
        camera.position.x = -1500;

        // controls 
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.minDistance = 100;
        controls.maxDistance = 2500;
        controls.maxPolarAngle = Math.PI / 2;

        // world
        var world = new THREE.CylinderBufferGeometry(0, 10, 30, 4, 1);
        var material = new THREE.MeshNormalMaterial();

        //================== set scene ======================//
        var scene = new THREE.Scene();
        // set background color
        scene.background = new THREE.Color(0xa0a0a0);
        scene.fog = new THREE.Fog(0xa0a0a0, 200, 4000);
        //  set light
        {
            scene.add(new THREE.AmbientLight(0x666666));

            light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 200, 0);
            scene.add(light);

            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, 3000, 2000);
            light.castShadow = true;
            light.shadow.camera.top = 180;
            light.shadow.camera.bottom = - 100;
            light.shadow.camera.left = - 120;
            light.shadow.camera.right = 120;
            scene.add(light);
        }

        // ground
        var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(10000, 10000), new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false }));
        mesh.rotation.x = - Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);

        var grid = new THREE.GridHelper(10000, 100, 0x000000, 0x000000);
        grid.material.opacity = 0.05;
        grid.material.transparent = true;
        scene.add(grid);

        // ======== OBJ Loader ============ //
        function getStructure() {
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('{{include.obj}}');
            mtlLoader.load('{{include.mtl}}', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('{{include.obj}}');
                objLoader.load('{{include.mtl}}', function (object) {
                    scene.add(object);
                });
            });
        }
        function structureColor(color) {
            const material = new THREE.MeshStandardMaterial({ color });
            const loadStructure = new THREE.Mesh(getStructure(), material);
        };
        const newStructure= structureColor(0x44aa88);
        
        //===================== Events ======================//
        function resizeRendererToDisplaySize(renderer) {
            const canvas = document.querySelector('#{{include.id}}');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.clientHeight !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }
        // adding scene and camera to the render
        function render(time) {
            time *= 0.001;
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = document.querySelector('#{{include.id}}');
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix
            }
            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    }


    main();

</script>