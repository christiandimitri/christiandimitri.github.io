<div class="column">
    <div class="card">
        <div class="card-image medium-height">
            <canvas id='{{include.id}}' class="threeJS-canvas"></canvas>
        </div>
    </div>
</div>


<script>
    // Our Javascript will go here.
    // console.clear();

    function main() {
        //========= set renderer to 'canvas id' ===============//
        const canvas = document.querySelector('#{{include.id}}');
        // set renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        //================== set camera ======================//
        const fov = 45;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 1;
        const far = 6000;
        var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.lookAt(new THREE.Vector3(0, 0, 0)); // Set look at coordinate like this
        camera.position.z = 1000;
        camera.position.y = 1000;
        camera.position.x = -1500;

        // world
        var world = new THREE.CylinderBufferGeometry(0, 10, 30, 4, 1);
        var material = new THREE.MeshNormalMaterial();

        //================== set scene ======================//
        var scene = new THREE.Scene();
        // set background color
        scene.background = new THREE.Color(0xa0a0a0);
        scene.fog = new THREE.Fog(0xa0a0a0, 200, 6000);

        //  set light

        var light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 1000, 0);
        light.castShadow = true;
        scene.add(light);

        // set up shadow properties for the light
        light.shadow.mapSize.width = 512;
        light.shadow.mapSize.height = 512;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 1000;



        // ground

        var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(100000, 100000), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        ground.rotation.x = - Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // var grid = new THREE.GridHelper(10000, 100, 0x000000, 0x000000);
        // grid.material.opacity = 0.05;
        // grid.material.transparent = true;
        // scene.add(grid);

        // controls 
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;
        controls.minDistance = 100;
        controls.maxDistance = 3000;
        controls.maxPolarAngle = Math.PI / 2;

        // ============== compute scene boundingbox ====================//


        // ============ TODO loading buffer ==============//




        // ======== OBJ Loader ============ //
        function loadModel(color) {
            var objLoader = new THREE.OBJLoader();
            objLoader.setPath('/assets/models/obj/');
            objLoader.load('{{include.obj}}', function (object) {
                object.traverse(child => {
                    if (child.material) child.material = new THREE.MeshStandardMaterial({ color });
                })
                scene.traverse(function (child) {
                    if (child.isMesh) {

                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                })
                scene.add(object);
            });
        }
        var model = loadModel('{{ include.color }}');
        //===================== Events ======================//
        function resizeRendererToDisplaySize(renderer) {
            const canvas = document.querySelector('#{{include.id}}');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.clientHeight !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

        // ====================== helpers ==========//
        var helper = new THREE.CameraHelper(light.shadow.camera);
        scene.add(helper);

        // adding scene and camera to the render
        function render(time) {
            time *= 0.001;
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = document.querySelector('#{{include.id}}');
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix;
            };
            renderer.render(scene, camera);

            requestAnimationFrame(render);
        };

        requestAnimationFrame(render);
    }


    main();

</script>